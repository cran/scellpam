<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Juan Domingo" />


<title>parallelpamsc</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">parallelpamsc</h1>
<h4 class="author">Juan Domingo</h4>



<div id="please-read-this" class="section level1">
<h1>Please, read this</h1>
<p>This is a copy of the vignette of package <code>parallelpam</code>.
It is included here since parallelpam is underlying this package and you
will need to know how does it work to process the single cell data using
the PAM algorithm. But you must NOT load package
<code>parallelpam</code>. All the functions detailed below are already
included into <code>scellpam</code> and are available just by loading it
with <code>library(scellpam)</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(scellpam)</span></code></pre></div>
</div>
<div id="purpose" class="section level1">
<h1>Purpose</h1>
<p>The <code>parallelpam</code> package (<span class="citation">Domingo
(2023c)</span>) is meant as a way to apply the PAM algorithm to quite
(or very) big sets of data, such as the results of single-cell
sequencing, but can be generally used for any type of data, as long as a
distance/dissimilarity matrix can be calculated.</p>
<p>Differently to other packages, its main strength is its ability to
perform clustering based on Partitioning Around Medoids (PAM) using a
large number of items and doing it in parallel. Memory and speed
limitations are reduced by extensive use of C++ programming which allows
use of alternative data types (for instance, float vs.Â double to
represent distance/dissimilarity), intermediate disk-storage to avoid
memory copy operations whenever possible and use of threads.</p>
<p>Both phases of PAM (initialization with <code>BUILD</code> and
optimization) have been parallelized so it you have a multi-core
machine, many threads will be launched with a great acceleration of the
calculations. This is done automatically, even you are allowed to choose
the number of threads yourself for comparison purposes or to allow your
machine to execute other things simultaneously.</p>
<p>Also, calculation of the matrix of distances/dissimilarities from the
initial data and calculation of silhouette of the resulting
clusterization are available, too, and are calculated in parallel in a
multi-core machine.</p>
<p>The data are stored in memory reading them from binary files created
with the package <code>jmatrix</code> (<span class="citation">Domingo
(2023b)</span>). To be familiar with them please read the vignette
called <code>jmatrixsc</code> which is included with this package.</p>
<p>WARNING: you must NOT load neither <code>jmatrix</code> nor
<code>parallelpam</code> explicitly. Indeed, you do not need even to
install them. All their functions have been included here, too, so doing
<code>library(scellpam)</code> is enough.</p>
</div>
<div id="workflow" class="section level1">
<h1>Workflow</h1>
<div id="debug-messages" class="section level2">
<h2>Debug messages</h2>
<p>First of all, the package can show quite informative (but sometimes
verbose) messages in the console. To turn on/off such messages you can
use</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initially, state of debug is FALSE. Turn it on exclusively for the</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># parallelpam part with</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ScellpamSetDebug</span>(<span class="cn">FALSE</span>,<span class="at">debparpam=</span><span class="cn">TRUE</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Debugging for parallelpam inside scellpam package set to ON.</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># There is another parameter, debjmat, to turn on messages about</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># binary matrix creation/manipulation. By default is FALSE but turn it on</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># if you like with</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ScellpamSetDebug(FALSE,debparpam=TRUE,debjmat=TRUE)</span></span></code></pre></div>
</div>
<div id="data-loadstorage" class="section level2">
<h2>Data load/storage</h2>
<p>The first step is to load raw data coming from external sources like
the main formats used in single cell experiments which should have been
stored as a binary matrix file in <code>jmatrix</code> format. Since
this is a separate package, and for purposes of illustration, we will
create an artificial matrix for a small problem that fits in
<code>R</code> memory with 5000 vectors with 500 dimensions each. Then
we will calculate the dissimilarity matrix and finally we will apply the
PAM algorithm to it.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the matrix with row names V1 to V5000 and column names d1 to d500</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>nvec<span class="ot">&lt;-</span><span class="dv">5000</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ndim<span class="ot">&lt;-</span><span class="dv">500</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>P<span class="ot">&lt;-</span><span class="fu">matrix</span>(<span class="fu">runif</span>(nvec<span class="sc">*</span>ndim),<span class="at">nrow=</span>nvec)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(P)<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">&quot;V&quot;</span>,<span class="dv">1</span><span class="sc">:</span>nvec)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(P)<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">&quot;d&quot;</span>,<span class="dv">1</span><span class="sc">:</span>ndim)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Write it to disk as a binary file in jmatrix format. Please,</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># see vignette jmatrixsc.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="fu">JWriteBin</span>(P,<span class="st">&quot;datatest.bin&quot;</span>,<span class="at">dtype=</span><span class="st">&quot;float&quot;</span>,<span class="at">dmtype=</span><span class="st">&quot;full&quot;</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>          <span class="at">comment=</span><span class="st">&quot;Synthetic problem data to test PAM&quot;</span>)</span></code></pre></div>
<p>For your real problem, the input format can be a <code>.csv</code>
file. See function <code>CsvToJMat</code> in package
<code>scellpam</code> (<span class="citation">Domingo
(2023a)</span>).</p>
<p>To know details about the generated files do</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">JMatInfo</span>(<span class="st">&quot;datatest.bin&quot;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; File:               datatest.bin</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Matrix type:        FullMatrix</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of elements: 2500000</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Data type:          float</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Endianness:         little endian (same as this machine)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of rows:     5000</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of columns:  500</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Metadata:           Stored names of rows and columns.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Metadata comment:  &quot;Synthetic problem data to test PAM&quot;</span></span></code></pre></div>
</div>
<div id="calculating-the-distancedissimilarity-matrix" class="section level2">
<h2>Calculating the distance/dissimilarity matrix</h2>
<p>This is the most computationally intensive part of the process
(particularly, for samples with a high number of points and/or high
dimensionality) and therefore has been programmed in parallel, taking
advantage of the multiple cores of the machine, if available. The
funcion is called <code>CalcAndWriteDissimilarityMatrix</code>. Its
input and output files (first and second parameters) are of course
compulsory. Input file can be a sparse of full binary
<code>jmatrix</code> (but obviously, not a symmetric matrix).</p>
<p>WARNING: notice that the vectors to calculate dissimilarities amongst
them MUST be stored BY ROWS. This is due to efficiency reasons.</p>
<p>Output dissimilarity matrix will always be a binary symmetric
(obviously square) matrix with a number of rows (and columns) equal to
the number of rows (in this case, vectors) of the input file. The type
of distance/dissimilarity can be <code>L1</code> (Manhattan distance),
<code>L2</code> (Euclidean distance) or <code>Pearson</code> (Pearson
dissimilarity coefficient). The resulting matrix stores only names for
the rows, which are the names of the vectors stored as rows in file
<code>datatest.bin</code>. If the number of vectors is <span class="math inline">\(N\)</span>, only <span class="math inline">\(N(N+1)/2\)</span> dissimilarity values are really
stored.</p>
<p>A note on the number of threads, valid also for other algorithms that
will be explained later:</p>
<p>Possible values for the number of threads are:</p>
<ul>
<li><p><code>-1</code> (or any negative number) to indicate you do not
want to use threads (strictly sequential computation).</p></li>
<li><p><code>0</code> to allow the program to choose the number of
threads according to the problem size and the number of available
cores.</p></li>
<li><p>Any positive number to force the use of such number of
threads.</p></li>
</ul>
<p>Choosing explicitly a number of threads bigger than the number of
available cores is allowed, but discouraged and the program emits a
warning about it.</p>
<p>With respect to option <code>0</code>, for small problems (in this
case, less than 1000 vectors) the function makes the choice of not using
threads, since the overhead of opening and waiting termination is not
worth. For bigger problems the number of chosen threads is the number of
available cores, or twice this number if the processor is capable of
hyperthreading. Nevertheless, this choice may not be the best, depending
on your machine, possibly due (I guess) to the memory access conflicts
created by the need of keep processor cache coherence. You may have to
do some trials with your data in your machine.</p>
<p>Now, let us try it with this small dataset.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">CalcAndWriteDissimilarityMatrix</span>(<span class="st">&quot;datatest.bin&quot;</span>,<span class="st">&quot;datatestL2.bin&quot;</span>,</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                                <span class="at">distype=</span><span class="st">&quot;L2&quot;</span>,<span class="at">restype=</span><span class="st">&quot;float&quot;</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                                <span class="at">comment=</span><span class="st">&quot;L2 distance for vectors in</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="st"> jmatrix file datatest.bin&quot;</span>,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Input matrix is a full matrix  with elements of type &#39;float&#39; and size (5000,500)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Read full matrix from file datatest.bin. Its size is [5000 x 500] and it uses 2500000 elements of 4 bytes each with accounts for 9.53674 MBytes.</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Creating dissimilarity matrix of size (5000x5000)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: memuse</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 255859508 Kib.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; End of dissimilarity matrix calculation (serial version). Elapsed time: 19.7453 s</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Output binary file datatestL2.bin written.</span></span></code></pre></div>
<p>WARNING: the normal way of calling
<code>CalcAndWriteDissimilarityMatrix</code> would use nthreads=0 to
make use of all available cores in your machine. Nevertheless, this does
not seem to be allowed by CRAN to pass the test so I have had to use the
serial version invoked with nthreads=-1. In your normal use of code try
always nthreads=0.</p>
<p>The resulting matrix is stored as a binary symmetric matrix of float
values, as we can check.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">JMatInfo</span>(<span class="st">&quot;datatestL2.bin&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; File:               datatestL2.bin</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Matrix type:        SymmetricMatrix</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of elements: 25000000 (12502500 really stored)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Data type:          float</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Endianness:         little endian (same as this machine)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of rows:     5000</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Number of columns:  5000</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Metadata:           Stored only names of rows.</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Metadata comment:  &quot;L2 distance for vectors in</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  jmatrix file datatest.bin&quot;</span></span></code></pre></div>
</div>
<div id="applying-pam" class="section level2">
<h2>Applying PAM</h2>
<p>The last step is to take the previously calculated matrix and apply
the Partitioning Around Medoids classifier. Function is
<code>ApplyPAM</code>. First parameter (name of the file containing the
dissimilarity matrix in <code>jmatrix</code> format) and second
parameter (<code>k</code>, number of medoids) are compulsory. The names
and default values for the rest of parameters are as in this
example.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>L<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">k=</span><span class="dv">5</span>,<span class="at">init_method=</span><span class="st">&quot;BUILD&quot;</span>,<span class="at">max_iter=</span><span class="dv">1000</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2.bin</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256178316 Kib.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting BUILD initialization method, serial version</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 1. Medoid 1 found. Point 2987. TD=8.798232</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 2. Medoid 2 found. Point 2579. 2458 reassigned points. TD=8.692621</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 3. Medoid 3 found. Point 1126. 1581 reassigned points. TD=8.638234</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 4. Medoid 4 found. Point 4460. 1120 reassigned points. TD=8.602614</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 5. Medoid 5 found. Point 3863. 891 reassigned points. TD=8.577416</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Current TD: 8.577416</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; BUILD initialization method (serial version) finished. Elapsed time: 0.317203 s</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting improved FastPAM1 method in serial implementation...</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 0.    Exiting, since DeltaTDst is 0.000000. Final value of TD is 8.577407</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Optimization method (serial version) finished. Elapsed time: 0.0614121 s</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0.317203 s (method BUILD).</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0.0614121 s in 0 iterations.</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.378615 s (0 minutes, 0.378615 seconds).</span></span></code></pre></div>
<p>WARNING: the normal way of calling <code>ApplyPAM</code> would use
nthreads=0 to make use of all available cores in your machine.
Nevertheless, this does not seem to be allowed by CRAN to pass the test
so I have had to use the serial version invoked with nthreads=-1. In
your normal use of code try always nthreads=0.</p>
<p>Parameters <code>init_method</code> (and another optional parameter,
<code>initial_med</code>) deserve special comment. The first is the
method to initialize the medoids. Its possible values are
<code>BUILD</code>, <code>LAB</code> and <code>PREV</code>. The rest of
the algorithm make medoid swapping between the points of the initial set
made with <code>BUILD</code> or <code>LAB</code> and the rest of points
until no swap can reduce the objective function, which is the sum of
distances of each point to its closest medoid. But this may fall (and
indeed falls) in local minima. If you initialize with <code>BUILD</code>
or <code>LAB</code> the optional parameter <code>initial_med</code>
cannot be used.</p>
<p>The initialization methods <code>BUILD</code> and <code>LAB</code>
are described in the paper from Schubert at al.Â (<span class="citation">Schubert and Rousseeuw (2019)</span>).
<code>BUILD</code> is deterministic. <code>LAB</code> uses a sample of
the total points to initialize. Obviously, you can run <code>LAB</code>
to get different initializations and compare the results.</p>
<p>The returned object is a list with two fields: <code>med</code> and
<code>clasif</code>. This will be explained later.</p>
<p>From now on, typical calls to obtain only the initial medoids would
be</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Lbuild<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">k=</span><span class="dv">5</span>,<span class="at">init_method=</span><span class="st">&quot;BUILD&quot;</span>,<span class="at">max_iter=</span><span class="dv">0</span>,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2.bin</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256142540 Kib.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting BUILD initialization method, serial version</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 1. Medoid 1 found. Point 2987. TD=8.798232</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 2. Medoid 2 found. Point 2579. 2458 reassigned points. TD=8.692621</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 3. Medoid 3 found. Point 1126. 1581 reassigned points. TD=8.638234</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 4. Medoid 4 found. Point 4460. 1120 reassigned points. TD=8.602614</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 5. Medoid 5 found. Point 3863. 891 reassigned points. TD=8.577416</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Current TD: 8.577416</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; BUILD initialization method (serial version) finished. Elapsed time: 0.320641 s</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0.320641 s (method BUILD).</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0 s in 0 iterations.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.320641 s (0 minutes, 0.320641 seconds).</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Llab1<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">k=</span><span class="dv">5</span>,<span class="at">init_method=</span><span class="st">&quot;LAB&quot;</span>,<span class="at">max_iter=</span><span class="dv">0</span>,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2.bin</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256184624 Kib.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting LAB initialization method, serial version.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 1. Medoid 1 found. Point 1125. TD=8.818431</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 2. Medoid 2 found. Point 3602. 1972 reassigned points. TD=8.739282</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 3. Medoid 3 found. Point 3049. 1178 reassigned points. TD=8.700571</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 4. Medoid 4 found. Point 3189. 1341 reassigned points. TD=8.654654</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 5. Medoid 5 found. Point 1210. 735 reassigned points. TD=8.635015</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Current TD: 8.635015</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; LAB initialization method (serial version) finished. Elapsed time: 0.00125725 s</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0.00125725 s (method LAB).</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0 s in 0 iterations.</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.00125725 s (0 minutes, 0.00125725 seconds).</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Llab2<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">k=</span><span class="dv">5</span>,<span class="at">init_method=</span><span class="st">&quot;LAB&quot;</span>,<span class="at">max_iter=</span><span class="dv">0</span>,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2.bin</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256144296 Kib.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting LAB initialization method, serial version.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 1. Medoid 1 found. Point 2373. TD=8.857759</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 2. Medoid 2 found. Point 4976. 2170 reassigned points. TD=8.765445</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 3. Medoid 3 found. Point 3388. 1577 reassigned points. TD=8.711335</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 4. Medoid 4 found. Point 2417. 1151 reassigned points. TD=8.674360</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Looking for medoid 5. Medoid 5 found. Point 2452. 973 reassigned points. TD=8.645628</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Current TD: 8.645628</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; LAB initialization method (serial version) finished. Elapsed time: 0.0012494 s</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0.0012494 s (method LAB).</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0 s in 0 iterations.</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.0012494 s (0 minutes, 0.0012494 seconds).</span></span></code></pre></div>
<p>WARNING: the normal way of calling <code>ApplyPAM</code> would use
nthreads=0 to make use of all available cores in your machine.
Nevertheless, this does not seem to be allowed by CRAN to pass the test
so I have had to use the serial version invoked with nthreads=-1. In
your normal use of code try always nthreads=0. For the LAB method this
does not matter, since parallel implementation is not yet provided.</p>
<p>As it can be seen, to get and compare different initializations you
must set the parameter <code>max_iter</code> to the value
<code>0</code>. In this case no iterations of objective function
reduction are performed, and the returned object contains the initial
medoids and the classification induced by them. Notice that even looking
equal, the results of the latter two calls are different since
<code>LAB</code> initializes with a random component (the sample to
choose initial medoids is chosen randomly).</p>
<p>You can check that the medoids, stored in <code>Llab1$med</code> and
<code>Llab2$med</code> (see more on this below) are in general
different.</p>
<p>Now, these results can be used to initialize <code>PAM</code> if you
find that any of them contains a specially good set of medoids. This is
the role of method <code>PREV</code> that we have mentioned before. A
typical call would be</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Llab2Final<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">k=</span><span class="dv">5</span>,<span class="at">init_method=</span><span class="st">&quot;PREV&quot;</span>,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">initial_med=</span>Llab2<span class="sc">$</span>med,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2.bin</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256144296 Kib.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting improved FastPAM1 method in serial implementation...</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 0. Medoid at place 2 (point 4976) swapped with point 2988; TD-change=-0.027064; TD=8.618556. 1621 reassigned points.</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 1. Medoid at place 4 (point 2417) swapped with point 1126; TD-change=-0.015580; TD=8.602976. 1372 reassigned points.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 2. Medoid at place 3 (point 3388) swapped with point 2579; TD-change=-0.012838; TD=8.590137. 1293 reassigned points.</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 3. Medoid at place 5 (point 2452) swapped with point 4460; TD-change=-0.010259; TD=8.579878. 1119 reassigned points.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 4. Medoid at place 1 (point 2374) swapped with point 3863; TD-change=-0.002470; TD=8.577408. 1096 reassigned points.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 5.    Exiting, since DeltaTDst is 0.000000. Final value of TD is 8.577408</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Optimization method (serial version) finished. Elapsed time: 0.383343 s</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0 s (method PREV).</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0.383343 s in 4 iterations (0.0958359 seconds/iteration).</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.383343 s (0 minutes, 0.383343 seconds).</span></span></code></pre></div>
<p>The initial set of medoids is taken from the object returned by the
former calls.</p>
<p>With respect to that object, as we said it is a list with two
vectors. The first one, <code>L$med</code>, has as many components as
requested medoids and the second, <code>L$clasif</code>, has as many
components as instances.</p>
<p>Medoids are expressed in <code>L$med</code> by its number in the
array of vectors (row number in the dissimilarity matrix) starting at 1
(<code>R</code> convention).</p>
<p><code>L$clasif</code> contains the number of the medoid (i.e.: the
cluster) to which each instance has been assigned, according to their
order in <code>L$med</code> (also from 1).</p>
<p>This means that if <code>L$clasif[p]</code> is <code>m</code>, the
point <code>p</code> belongs to the class grouped around medoid
<code>L$med[m]</code>. Let us see it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Which are the indexes of the points chosen as medoids?</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>L<span class="sc">$</span>med</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; V2988 V2579 V1126 V4460 V3863 </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  2988  2579  1126  4460  3863</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"># In which class has point 147 been classified?</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>L<span class="sc">$</span>clasif[<span class="dv">147</span>]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; V147 </span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    4</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># And which is the index (row in the dissimilarity matrix)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># of the medoid closest to point 147?</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>L<span class="sc">$</span>med[L<span class="sc">$</span>clasif[<span class="dv">147</span>]]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; V4460 </span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  4460</span></span></code></pre></div>
<p>In this way, values in <code>L$clasif</code> are between 1 and the
number of medoids, as we can see:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min</span>(L<span class="sc">$</span>clasif)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span>(L<span class="sc">$</span>clasif)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 5</span></span></code></pre></div>
<p>They can be used as factors.</p>
</div>
<div id="calculating-silhouette" class="section level2">
<h2>Calculating silhouette</h2>
<p>It is interesting to filter points based on the degree in which they
belong to a cluster. Indeed, cluster refinement can be done getting rid
of points far away from any cluster center, or which are at a similar
distance of two or more of them.</p>
<p>This is characterized by the silhouette of each point. Three
functions deal with this: <code>CalculateSilhouette</code>,
<code>FilterBySilhouetteQuantile</code> and
<code>FilterBySilhouetteThreshold</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>S<span class="ot">=</span><span class="fu">CalculateSilhouette</span>(Llab2<span class="sc">$</span>clasif,<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 48837 KiB, which is 0.01% of the available memory, which is 256107440 Kib.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Calculating silhouette (serial implementation)...</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5000 points classified in 5 classes.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Finished serial implementation of silhouette (including dissimilarity matrix load). Elapsed time: 0.0808602 s</span></span></code></pre></div>
<p>WARNING: the normal way of calling <code>CalculateSilhouette</code>
would use nthreads=0 to make use of all available cores in your machine.
Nevertheless, this does not seem to be allowed by CRAN to pass the test
so I have had to use the serial version invoked with nthreads=-1. In
your normal use of code try always nthreads=0.</p>
<p>The parameters to function <code>CalculateSilhouette</code> are the
array of class membership, as returned by <code>ApplyPAM</code> in its
<code>clasif</code> field, and the file with the matrix of
dissimilarities.</p>
<p>A parallel implementation has been programmed, being nthreads as
explained before.</p>
<p>Silhouette is a number in <span class="math inline">\([-1,1]\)</span>; the higher its value, the most
centered a point is in its cluster.</p>
<p>The returned object <code>S</code> is a numeric vector with the value
of the silhouette for each point, which will be a named vector if the
classification vector was named.</p>
<p>This vector can be converted to an object of the class
<code>cluster:silhouette</code> with the function
<code>NumSilToClusterSil</code> (which needs the vector of
classifications, too). This is done so that, if you load the package
<code>cluster</code> (<span class="citation">Maechler et al.
(2022)</span>), plot will generate the kind of silhouette plots included
in such package.</p>
<p>If the package cluster is installed you can try to execute this:
(Sorry, we canât try ourselves since we donât know if cluster is
installed in your system and the CRAN check does not allow the use of
installed.packages to test it)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Sclus <span class="ot">&lt;-</span> <span class="fu">NumSilToClusterSil</span>(Llab2<span class="sc">$</span>clasif,S)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cluster)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Sclus)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Probably the plot does not look very nice with this random data which
yields a very bad clustering (since the points are not, by its own
nature, organized in clusters) but with real data you should see
significant things (see package <code>scellpam</code> (<span class="citation">Domingo (2023a)</span>)).</p>
<p>Once the silhouette is calculated we can filter it by quantile or by
threshold. All points under this quantile or threshold will be
discarded, except if they are medoids. Parameters are:</p>
<ul>
<li><p>The silhouette, as returned by
<code>CalculateSilhouette</code>.</p></li>
<li><p>The list of medoids/clasif, as returned by
<code>ApplyPAM</code>.</p></li>
<li><p>The file with matrix of counts for the whole set of cells, which
was our first input.</p></li>
<li><p>The file that will contain the matrix of counts of the remaining
cells.</p></li>
<li><p>The file with the dissimilarity matrix for the whole set, as
calculated by <code>CalcAndWriteDissimilarityMatrix</code>.</p></li>
<li><p>The file that will contain the dissimilarity for the remaining
cells.</p></li>
<li><p>And (depending on the function used) the quantile in <span class="math inline">\([0,1]\)</span> or the silhouette threshold in
<span class="math inline">\([-1,1]\)</span>.</p></li>
</ul>
<p>As an example,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>Lfilt<span class="ot">=</span><span class="fu">FilterBySilhouetteQuantile</span>(S,Llab2,<span class="st">&quot;datatest.bin&quot;</span>,</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>                                 <span class="st">&quot;datatestFilt.bin&quot;</span>,<span class="st">&quot;datatestL2.bin&quot;</span>,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="st">&quot;datatestL2Filt.bin&quot;</span>,<span class="fl">0.2</span>)</span></code></pre></div>
<p>If the original matrix contained row and column names, the column
names are copied and the row names are transported for those rows that
remain. The same happens with respect to rows of the dissimilarity
matrix.</p>
<p>Notice that the new dissimilarity matrix could have been calculated
from the matrix of filtered counts with
<code>CalcAndWriteDissimilarityMatrix</code> but creating it here,
simply getting rid of the filtered rows and columns is much faster.</p>
<p>Also, if a medoid is below the silhouette quantile, it will not be
filtered out, but a warning message will be shown, since this is a
strange situation that may indicate that some of your clusters are not
real but artifacts due to a few outliers that are close to each
other.</p>
<p>But remember that this was the result of the first step of the PAM
algorithm, so probably you will want to make them iterate.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>Lfinal<span class="ot">=</span><span class="fu">ApplyPAM</span>(<span class="st">&quot;datatestL2Filt.bin&quot;</span>,<span class="at">k=</span><span class="fu">length</span>(Lfilt<span class="sc">$</span>med),</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">init_method=</span><span class="st">&quot;PREV&quot;</span>,<span class="at">initial_med=</span>Lfilt<span class="sc">$</span>med,<span class="at">nthreads=</span><span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Reading symmetric distance/dissimilarity matrix datatestL2Filt.bin</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Package memuse is installed. OK.</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Memory used by the matrix: 31257 KiB, which is 0.01% of the available memory, which is 256092544 Kib.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   That seems OK.</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Matrix is a correct distance/dissimilarity matrix.</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Starting improved FastPAM1 method in serial implementation...</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span><span class="al">WARNING</span><span class="co">: all successive messages use R-numbering (from 1) for points and medoids. Substract 1 to get the internal C-numbers.</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 0. Medoid at place 2 (point 3981) swapped with point 2385; TD-change=-0.021357; TD=8.605878. 1226 reassigned points.</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 1. Medoid at place 3 (point 2714) swapped with point 906; TD-change=-0.012773; TD=8.593104. 1049 reassigned points.</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 2. Medoid at place 4 (point 1935) swapped with point 2063; TD-change=-0.010820; TD=8.582285. 989 reassigned points.</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 3. Medoid at place 5 (point 1964) swapped with point 3422; TD-change=-0.003460; TD=8.578824. 901 reassigned points.</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 4. Medoid at place 1 (point 1899) swapped with point 3080; TD-change=-0.000778; TD=8.578047. 860 reassigned points.</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Iteration 5.    Exiting, since DeltaTDst is 0.000000. Final value of TD is 8.578047</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Optimization method (serial version) finished. Elapsed time: 0.244156 s</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Time summary  (serial implementation).</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Initalization: 0 s (method PREV).</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Optimization:  0.244156 s in 4 iterations (0.0610389 seconds/iteration).</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Total time:    0.244156 s (0 minutes, 0.244156 seconds).</span></span></code></pre></div>
<p>WARNING: the normal way of calling <code>ApplyPAM</code> would use
nthreads=0 to make use of all available cores in your machine.
Nevertheless, this does not seem to be allowed by CRAN to pass the test
so I have had to use the serial version invoked with nthreads=-1. In
your normal use of code try always nthreads=0.</p>
<p>Of course, we might have used simply 5 as number of medoids,
<code>k</code>, since this does not change by filtering, but this is to
emphasize the fact that <code>ApplyPAM</code> with method
<code>PREV</code> requires both parameters to be consistent.</p>
</div>
<div id="comparison-with-other-pam-implementations" class="section level2">
<h2>Comparison with other PAM implementations</h2>
<p>The user might want to compare this PAM implementation with others
provided for instance by packages <code>cluster</code> (<span class="citation">Maechler et al. (2022)</span>) or <code>ClusterR</code>
(<span class="citation">Mouselimis (2023)</span>). In
<code>cluster</code> the input is either the data matrix (so the
distance matrix is calculated inside the pam function) or directly the
distance matrix but as a R vector with the lower-diagonal part of the
symmetric matrix ordered by columns (i.e.: column 1 from M(2,1) to
M(n,1), followed by column 2 from M(3,2) to M(n,2) and so on, up to
M(n,n-1). This is a vector of <span class="math inline">\(n(n-1)/2\)</span> components. To facilitate such
comparison the function <code>GetSubdiag</code> is provided which takes
as input the jmatrix file with the distance matrix and returns the
vector to be passed to pam in the aforementioned packages.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">GetSubdiag</span>(<span class="st">&quot;datatestL2.bin&quot;</span>)</span></code></pre></div>
<p>Then, explicit comparison could be done with:</p>
<p>(Sorry, we canât try ourselves since we donât know if cluster is
installed in your system and the CRAN check does not allow the use of
installed.packages to test it)</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cluster)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>clusterpam <span class="ot">=</span> <span class="fu">pam</span>(d,<span class="at">diss=</span><span class="cn">TRUE</span>,<span class="at">k=</span><span class="dv">5</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">sort</span>(clusterpam<span class="sc">$</span>id.med))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">sort</span>(L<span class="sc">$</span>med))</span></code></pre></div>
<p>Similarly, you can check against the ClusterR package. In this
package you need the complete dissimilarity matrix to be passed so we
have to get it:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Be patient, this may take some time...</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>Dm <span class="ot">=</span> <span class="fu">GetJManyRows</span>(<span class="st">&quot;datatestL2.bin&quot;</span>,<span class="fu">seq</span>(<span class="dv">1</span><span class="sc">:</span>nvec))</span></code></pre></div>
<p>and then</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ClusterR)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>ClusterRpam <span class="ot">=</span> <span class="fu">Cluster_Medoids</span>(Dm,<span class="at">clusters=</span><span class="dv">5</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">sort</span>(ClusterRpam<span class="sc">$</span>medoid_indices))</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">sort</span>(L<span class="sc">$</span>med))</span></code></pre></div>
<p>In all cases we tried with this simple (but random) example results
were the same. In other cases with a large number of points some medoids
were different in the different implementations but the value of the
function to minimize (sum of distances) was always the same, indicating
that they were equivalent minima. You can test this with function
<code>GetTD</code> as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>TDparallelpam <span class="ot">=</span> <span class="fu">GetTD</span>(L,<span class="st">&quot;datatestL2.bin&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This is to adapt cluster package output format to ours, since this is what our GetTD function expects...</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>Lcl <span class="ot">=</span> <span class="fu">list</span>()</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>Lcl<span class="sc">$</span>med <span class="ot">=</span> clusterpam<span class="sc">$</span>id.med</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>Lcl<span class="sc">$</span>clasif <span class="ot">=</span> clusterpam<span class="sc">$</span>clustering</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>TDcluster <span class="ot">=</span> <span class="fu">GetTD</span>(Lcl,<span class="st">&quot;datatestL2.bin&quot;</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co"># The same with ClusterR package:</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>LclR <span class="ot">=</span> <span class="fu">list</span>()</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>LclR<span class="sc">$</span>med <span class="ot">=</span> ClusterRpam<span class="sc">$</span>medoid_indices</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>LclR<span class="sc">$</span>clasif <span class="ot">=</span> ClusterRpam<span class="sc">$</span>clusters</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>TDClusterR <span class="ot">=</span> <span class="fu">GetTD</span>(LclR,<span class="st">&quot;datatestL2.bin&quot;</span>)</span></code></pre></div>
<p>and see that variables <code>TDparallelpam</code>,
<code>TDcluster</code> and <code>TDClusterR</code> are equal.</p>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-R-scellpam" class="csl-entry">
Domingo, Juan. 2023a. <em>Applying Partitioning Around Medoids to Single
Cell Data with High Number of Cells</em>.
</div>
<div id="ref-R-jmatrix" class="csl-entry">
âââ. 2023b. <em>Jmatrix: Read from/Write to Disk Matrices with Any Data
Type in a Binary Format</em>.
</div>
<div id="ref-R-parallelpam" class="csl-entry">
âââ. 2023c. <em>Parallelpam: Applies the Partitioning-Around-Medoids
(PAM) Clustering Algorithm to Big Sets of Data Using Parallel
Implementation, If Several Cores Are Available</em>.
</div>
<div id="ref-R-cluster" class="csl-entry">
Maechler, Martin, Peter Rousseeuw, Anja Struyf, Mia Hubert, and Kurt
Hornik. 2022. <em>Cluster: Cluster Analysis Basics and Extensions</em>.
<a href="https://CRAN.R-project.org/package=cluster">https://CRAN.R-project.org/package=cluster</a>.
</div>
<div id="ref-R-ClusterR" class="csl-entry">
Mouselimis, Lampros. 2023. <em><span>ClusterR</span>: Gaussian Mixture
Models, k-Means, Mini-Batch-Kmeans, k-Medoids and Affinity Propagation
Clustering</em>. <a href="https://CRAN.R-project.org/package=ClusterR">https://CRAN.R-project.org/package=ClusterR</a>.
</div>
<div id="ref-Schubert2019" class="csl-entry">
Schubert, Erich, and Peter J. Rousseeuw. 2019. <span>âFaster k-Medoids
Clustering: Improving the <span>PAM</span>, <span>CLARA</span>, and
<span>CLARANS</span> Algorithms.â</span> In <em>Similarity Search and
Applications</em>, 171â87. Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-32047-8_16">https://doi.org/10.1007/978-3-030-32047-8_16</a>.
</div>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
